
// В переменную записываем функцию, принимающую два параметра, которая возвращает отфильтрованный массив. В данном случае массив с помощью spread оператора разбирается на элементы и тип данных каждого элемента сверяется с типом данных, который пользователь выбрал. Если есть совпадение между типами данных элемента и выбранного пользователем - функция возвращает этот элемент.
const filterByType = (type, ...values) => values.filter(value => typeof value === type),

	// В переменную записываем функцию, которая создает массив и перебирает его элементы
	hideAllResponseBlocks = () => {
		// Записываем в переменную массив из элементов, которые находятся внутри блока <div> с классом .dialog__response-block, полученных со страницы (массив DOM-элементов)
		const responseBlocksArray = Array.from(document.querySelectorAll('div.dialog__response-block'));
		// С помощью метода forEach перебираем полученный массив и каждому элементу задаем стиль display = 'none' (скрываем элемент)
		responseBlocksArray.forEach(block => block.style.display = 'none');
	},

	// В переменную записываем функцию, принимающую три параметра, с помощью которой будет выводиться нужное содержимое определенного сообщения (сообщение с результатом/ошибкой/отсутствием результата)
	showResponseBlock = (blockSelector, msgText, spanSelector) => {

		// Вызываем уже созданную функцию
		hideAllResponseBlocks();

		// Находим на странице элемент с переданным в качестве параметра функции селектором и даем ему стиль display = 'block' (делаем элемент видимым)
		document.querySelector(blockSelector).style.display = 'block';

		// Проверяем, существует ли с переданным в качестве параметра функции селектором элемент
		if (spanSelector) {

			// И если он существует, то передаем ему текст из параметра функции
			document.querySelector(spanSelector).textContent = msgText;
		}
	},

	// В переменную записываем функцию, которая будет выводить переданное ей сообщение об ошибке
	showError = msgText => showResponseBlock('.dialog__response-block_error', msgText, '#error'),

	// В переменную записываем функцию, которая будет выводить переданное ей сообщение об успешном результате
	showResults = msgText => showResponseBlock('.dialog__response-block_ok', msgText, '#ok'),

	// В переменную записываем функцию, которая будет выводить сообщение о том, что показываеть еще нечего (ни ошибки, ни результата)
	showNoResults = () => showResponseBlock('.dialog__response-block_no-results'),

	// В переменную записываем функцию, принимающую два параметра,которая будет определять, какое по содержанию сообщение для пользователя нужно выводить на экран
	tryFilterByType = (type, values) => {

		// Используем конструкцию try...catch для отлавливания возможных ошибок. Делаем это с той целью, чтобы скрипт не останавливался, если в процессе выполнения кода возникает ошибка. С помощью конструкции ловим ошибку и вместо прерывания скрипта указываем, как программе нужно отработать 
		try {

			// Создаем переменную, которая хранит в себе переделенный в строку массив, элементы разделены между собой через запятую с пробелом
			const valuesArray = eval(`filterByType('${type}', ${values})`).join(", ");

			// Создаем переменную, внутри которой будет проверяеться условие. Если созданная раннее строка имеет ненулевую длину, то выполнить...
			const alertMsg = (valuesArray.length) ?

				// ...вывод данных с таким то типом данных или...
				`Данные с типом ${type}: ${valuesArray}` :

				// ..иначе вывести сообщение об отстутствии такого типа данных
				`Отсутствуют данные типа ${type}`;

			// Осуществляем вызов функции
			showResults(alertMsg);

		// В случае возникновения ошибки в части кода внутри try {}, сделать...
		} catch (e) {

			// ...вызов функции, которая предупредит об ошибке
			showError(`Ошибка: ${e}`);
		}
	};

// В переменную записывем найденный элемент по id 
const filterButton = document.querySelector('#filter-btn');

// Добавляем обработчика событий при клике на кнопку
filterButton.addEventListener('click', e => {

	// В переменную записывем найденный элемент по id 
	const typeInput = document.querySelector('#type');

	// В переменную записывем найденный элемент по id 
	const dataInput = document.querySelector('#data');

	// Проверяем условие, если значение выбранного поля пустое, то сделать...
	if (dataInput.value === '') {

		// ...вывод сообщения о том, что поле не должно быть пустым и...
		dataInput.setCustomValidity('Поле не должно быть пустым!');

		// ...вызывать функцию
		showNoResults();

	// Иначе сделать...
	} else {

		// ...очистку поля,...
		dataInput.setCustomValidity('');

		// ...отмену стандартного поведения браузера при клике по кнопке,...
		e.preventDefault();

		// ...вызов функции, принимающей два значения из полей инпут, при чем у переданных значений убираются пробелы в начале и конце строки
		tryFilterByType(typeInput.value.trim(), dataInput.value.trim());
	}
});